#include <windows.h>

#include "readbytes.h"

// Read Bytes

// Memory Map PE
// Resolve imports 


typedef void EntryPoint(void);


int main(int argc, char* argv[]){
    if (argc != 2){
        printf("Usage: %s <path to PE>\n", argv[0]);
        return 0;
    }
    DWORD dwFileSize = 0;
    BYTE* lpFileBytes = LoadFileBytes(argv[1], &dwFileSize);
    if (lpFileBytes ==NULL){
        printf("Failed to load %s\n", lpFileBytes);
        return 0;
    }
    printf("Lets get ready to Load!\n");

    IMAGE_DOS_HEADER* lpImageDos = (IMAGE_DOS_HEADER*) lpFileBytes;
    IMAGE_NT_HEADERS* lpNtHeader = (IMAGE_NT_HEADERS*) (lpFileBytes  + lpImageDos->e_lfanew);
    IMAGE_OPTIONAL_HEADER optionalHeader = lpNtHeader->OptionalHeader;
    // get us the entry point RVA
    DWORD dwRVAEntry = optionalHeader.AddressOfEntryPoint;
    // THe size of headers 
    DWORD dwHeaderSize  = optionalHeader.SizeOfHeaders;
    DWORD dwImageSize = optionalHeader.SizeOfImage;
    printf("[+] The Memory mapped PE will be %d bytes!\n", dwImageSize);
    
    BYTE* lpBaseAddres  =(BYTE*) VirtualAlloc(
        NULL,
        dwImageSize, 
        MEM_RESERVE|MEM_COMMIT,
        PAGE_EXECUTE_READWRITE
    );
    if(lpBaseAddres ==NULL){
        printf("Failed to allocate memory because of %d\n", GetLastError());
        return 0;
    }
    memcpy(lpBaseAddres, lpFileBytes, dwHeaderSize);
    DWORD dwSections = lpNtHeader->FileHeader.NumberOfSections;
    
    IMAGE_SECTION_HEADER* sections = IMAGE_FIRST_SECTION(lpNtHeader);
    for(DWORD i = 0; i < dwSections; i++){
        void* dest =  (void*)(lpBaseAddres  + sections[i].VirtualAddress);
        void* src = (void*) (lpFileBytes + sections[i].PointerToRawData);
        printf("Copying section %s\n", sections[i].Name);
        if( sections[i].SizeOfRawData ==0){
            memset(dest, 0, sections[i].Misc.VirtualSize);
        } else{
            memcpy(dest, src, sections[i].SizeOfRawData);
            // DWORD y = sections[i].Misc.VirtualSize =SizeOfRawData
        }
    }
    return 0;
}

